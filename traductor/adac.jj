//*****************************************************************
// File:   adac.jj
// Author: ...........
// Date:   ...........
// Coms:   Un tutorial sobre el análisis léxico con javacc
//         https://javacc.github.io/javacc/tutorials/token-manager.html
//*****************************************************************

// options {
//   IGNORE_CASE = false;
//   COMMON_TOKEN_ACTION = false;
//   ...
//DEBUG_PARSER = true
// }

PARSER_BEGIN(adac)
package traductor;

public class adac {
    public static void main(String[] args) {
    	adac parser;

    	try {
	    	if(args.length == 0) { //entrada desde stdin
				parser = new adac(System.in);
			}
			else { //entrada desde fichero en args[0]
	            parser = new adac(new java.io.FileInputStream(args[0])); 
			}
			parser.programa(); //invoca símbolo inicial de la gramática
		} catch (java.io.FileNotFoundException e) {
			System.err.println ("Fichero " + args[0] + " no encontrado.");
		} catch (TokenMgrError e) {
        	System.err.println("LEX_ERROR: " + e.getMessage());
        } 
		catch (ParseException e){
			System.err.println("PARSE_ERROR: " + e.getMessage());
		}
    }
}
PARSER_END(adac)

TOKEN_MGR_DECLS:
{
	static void informacion(Token t, String tipo){
		System.out.println("(" + t.beginLine + "," + t.beginColumn + "): " + tipo + " \"" + t.image + "\"");
	}
}


//------------ descripción del AL
SKIP :
{
  	" "
|	"\t"
|	"\n"
|	"\r"
}

SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "--" (~["\n","\r"])* ("\n"|"\r"|"\r\n")> //Ojo si no hay final fichero pilla primero como operador
}



//<WithinComment> SKIP :
//{
// "\n" : DEFAULT
//}



TOKEN :
{
 	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >
|	< #ALPHANUM: (<LETTER> | <DIGIT>) >

}
//TokenManagerdecs
TOKEN :
{
 	< tBEGIN: "begin" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "inicio funcion");
 		}
|	< tBOOL: "boolean" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "declaracion boolean");
 		}
|	< tCHAR: "character" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "declaracion character");
 		}
|	< tINT: "integer" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "declaracion integer");
 		}
//constantes tipos
|	< tVINT: (<DIGIT>)+ >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "constante entera");
 		}
|	< tVCHAR: "'"(~["\n","\r"])"'" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "constante char");
 		}
|	< tTRUE: "true" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "constante bool true");
 		}
|	< tFALSE: "false" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "constante bool false");
 		}
|	< tVSTRING: "\""(~["\n","\r"])*"\"" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "constante string");
 		}
//simbolos
|	< tC: "," >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "simbolo coma");
 		}
|	< tPC: ";" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "simbolo punto y coma");
 		}
|	< tSBR: "(" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "simbolo parentesis abierto");
 		}
|	< tEBR: ")" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "simbolo parentesis cerrado");
 		}
|	< tISQBR: "[" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "simbolo corchete abierto");
 		}
|	< tESQBR: "]" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "simbolo corchete cerrado");
 		}
//logica
|	< tLESS: "<" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "operador mayor");
 		}
|	< tMORE: ">" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "operador menor");
 		}
|	< tLESSEQ: "<=" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "operador mayor o igual");
 		}
|	< tMOREEQ: ">=" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "operador menor o igual");
 		}
|	< tNOTEQ: "<>" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "operador igual");
 		}
|	< tASSIGN: ":=" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "operador asignacion");
 		}
|	< tEQ: "=" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "operador igual");
 		}
//aritmetica
|	< tNEG: "-" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "operador menos");
 		}
|	< tPOS: "+" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "operador mas");
 		}
|	< tMUL: "*" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "operador multiplicar");
 		}
|	< tDIV: "div" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "operador division");
 		}			
|	< tMOD: "mod" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "operador modulo");
 		}			  		 
//operaciones logicas
|	< tAND: "and" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "logica and");
 		}	
|	< tNOT: "not" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "logica not");
 		}	
|	< tOR: "or" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "logica or");
 		}	
//palabras reservadas en minusculas
|	< tPROC: "procedure" >
		{
 			//mostrar la información pedida
			informacion(matchedToken, "reservada procedure");
 		}
|	< tFUNCT: "function" >
		{
 			//mostrar la información pedida
			informacion(matchedToken, "reservada function");
 		}
|	< tRETURN: "return" >
		{
 			//mostrar la información pedida
			informacion(matchedToken, "reservada return");
 		}
|	< tVAL: "val" >
		{
 			//mostrar la información pedida
			informacion(matchedToken, "parametro por valor");
 		}
|	< tREF: "ref" >
		{
 			//mostrar la información pedida
			informacion(matchedToken, "parametro por referencia");
 		}
|	< tIS: "is" >
		{
 			//mostrar la información pedida
			informacion(matchedToken, "reservada is");
 		}
|	< tPUT: "put" >
		{
 			//mostrar la información pedida
			informacion(matchedToken, "operacion put");
 		}
|	< tPUTL: "put_line" >
		{
 			//mostrar la información pedida
			informacion(matchedToken, "operacion put_line");
 		}
|	< tGET: "get" >
		{
 			//mostrar la información pedida
			informacion(matchedToken, "operacion get");
 		}
|	< tI2C: "int2char" >
		{
 			//mostrar la información pedida
			informacion(matchedToken, "operacion int2char");
 		}
|	< tC2I: "char2int" >
		{
 			//mostrar la información pedida
			informacion(matchedToken, "operacion char2int");
 		}
|	< tEND: "end" >
		{
 			//mostrar la información pedida
			informacion(matchedToken, "reservada end");
 		}
|	< tIF: "if" >
		{
 			//mostrar la información pedida
			informacion(matchedToken, "condicion if");
 		}
|	< tELSE: "else" >
		{
 			//mostrar la información pedida
			informacion(matchedToken, "condicion else");
 		}
|	< tWHILE: "while" >
		{
 			//mostrar la información pedida
			informacion(matchedToken, "bucle while");
 		}
|	< tDO: "do" >
		{
 			//mostrar la información pedida
			informacion(matchedToken, "reservada do");
 		}
|	< tTHEN: "then" >		{
 			//mostrar la información pedida
			informacion(matchedToken, "reservada then");
 		}
//identificador
|	< tID: ("_"(<ALPHANUM>|<ALPHANUM>"_")* | <LETTER>("_"<ALPHANUM>|<ALPHANUM>)*("_")?) >
		{
 			//mostrar la información pedida
			informacion(matchedToken, "identificador");
 		}

}

TOKEN: 
{
	< tDEF: ~[] >		
		{
			System.out.println("ERROR LEXICO: (" + matchedToken.beginLine + "," + matchedToken.beginColumn + "): simbolo no reconocido: " + "<" + matchedToken.image + ">");			
		}
}


//------------ Símbolo inicial de la gramática. Para análisis léxico no hace falta más
void programa () : 
{

}
{
	<tPROC>
	<tID>
	<tIS>
	declaracion_variables()
	declaracion_procs_funcs()
	bloque_sentencias()
}

void declaracion_variables():
{

}
{
	( declaracion() <tPC> )*
}

void declaracion():
{
	
}
{
	tipo_variable() lista_vars()
}

void tipo_variable():
{

}
{
	<tINT> | <tCHAR> | <tBOOL>
}

void lista_vars():
{

}
{
	variable() ( <tC> variable() )*
}

void variable():
{
	
}
{
	LOOKAHEAD(2)
	<tID> <tISQBR> <tVINT> <tESQBR>	/*vectores*/
	| <tID>
}

void declaracion_procs_funcs():
{

}
{
	( declaracion_proc_func() )*
}

//...
void declaracion_proc_func():
{

}
{
	(<tPROC> | <tFUNCT> tipo_variable())
	declaracion_proc_func2()
}
//...

void declaracion_proc_func2():
{

}
{
	cabecera_proc_func()
	declaracion_variables()
	bloque_sentencias()
}

//...
void cabecera_proc_func():
{
	
}
{
	<tID> <tSBR> (argumentos_proc_func())? <tEBR> <tIS>
}

void argumentos_proc_func(): 
{
	
}
{
	(<tREF> | <tVAL>)
	declaracion()
	(<tPC> (<tREF> | <tVAL>) declaracion())*
}


//...
void bloque_sentencias():
{

}
{
	< tBEGIN> 
	(instruccion())*
	< tEND >
}

void instruccion():
{

}
{
	inst_asignacion() <tPC> 
	//| inst_escribir() <tPC> 
	| inst_escribir_linea() <tPC> 
	| inst_return() <tPC> 
}

void inst_return():
{

}
{
	<tRETURN> expresion()
}

void inst_asignacion():
{

}
{
	asignable()
	<tASSIGN>
	expresion()
}

void asignable():
{

}
{
	LOOKAHEAD(2)
	<tID> <tISQBR> expresion_simple() <tESQBR>	/*vectores*/
	| <tID>
}

/*void inst_escribir():
{

}
{

}*/

void inst_escribir_linea():
{

}
{
	<tPUTL> <tSBR> 
	((asignable() | <tVSTRING>) ( <tC> (asignable() | <tVSTRING> ))*)?		
	<tEBR>
}


/*

//...

void instruccion():
{

}
{
	inst_leer() <tPC>
	| inst_saltar_linea() <tPC> 

	| LOOKAHEAD(2)
		inst_invoc_proc() <tPC> 
	| inst_seleccion()
	| inst_iteracion()

}



//...

void inst_iteracion():
{
	
}
{
	<tWHILE>
	expresion()
	<tDO>
	lista_instruccionesO()
	<tEND>
}

//... skip_line() generar en c para ver que hace

void lista_cero_o_mas_exps():
{

}
{
	( lista_una_o_mas_exps() )?
}
*/
void expresion() : 
{

}
{
	expresion_simple() ( operador_relacional() expresion_simple() )?
}  

void operador_relacional():
{

}
{
	<tEQ>
	| <tLESS>
	| <tMORE>
	| <tLESSEQ>
	| <tMOREEQ>
	| <tNOTEQ>
}

void expresion_simple(): 
{

}
{
	( <tPOS> | <tNEG> )?
	termino() ( operador_aditivo() termino() )*
}

void operador_aditivo():
{

}
{
	<tPOS>
	| <tNEG>
	| <tOR>
}

void termino():
{
	
}
{
	factor() ( operador_multiplicativo() factor() )*
}

void operador_multiplicativo():
{

}
{
	<tMUL>
	| <tMOD>
	| <tDIV>
	| <tAND>
}

void factor():
{

}
{
	<tNOT> factor()
	| <tSBR> expresion() <tEBR>
	| <tI2C> <tSBR> expresion() <tEBR>
	| <tC2I> <tSBR> expresion() <tEBR>
	//| LOOKAHEAD(2)  <tID> <tSBR> lista_cero_o_mas_exps() <tEBR>
	| LOOKAHEAD(2)  <tID> <tISQBR> expresion() <tESQBR>
	| <tID>
	| <tVINT>
	| <tVCHAR>
	| <tVSTRING>
	| <tTRUE>
	| <tFALSE>
}