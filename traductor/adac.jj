//*****************************************************************
// File:   adac.jj
// Author: ...........
// Date:   ...........
// Coms:   Un tutorial sobre el análisis léxico con javacc
//         https://javacc.github.io/javacc/tutorials/token-manager.html
//*****************************************************************

// options {
//   IGNORE_CASE = false;
//   COMMON_TOKEN_ACTION = false;
//   ...
// }

PARSER_BEGIN(adac)
package traductor;

public class adac {
    public static void main(String[] args) {
    	adac parser;

    	try {
	    	if(args.length == 0) { //entrada desde stdin
				parser = new adac(System.in);
			}
			else { //entrada desde fichero en args[0]
	            parser = new adac(new java.io.FileInputStream(args[0])); 
			}
			parser.S(); //invoca símbolo inicial de la gramática
		} catch (java.io.FileNotFoundException e) {
			System.err.println ("Fichero " + args[0] + " no encontrado.");
		} catch (TokenMgrError e) {
        	System.err.println("LEX_ERROR: " + e.getMessage());
        } 
		catch (ParseException e){
			System.err.println("PARSE_ERROR: " + e.getMessage());
		}
    }
}
PARSER_END(adac)

TOKEN_MGR_DECLS:
{
	static void informacion(Token t, String tipo){
		System.out.println("(" + t.beginLine + "," + t.beginColumn + "): " + tipo + " \"" + t.image + "\"");
	}
}


//------------ descripción del AL
SKIP :
{
  	" "
|	"\t"
|	"\n"
|	"\r"
}

SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "--" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}



//<WithinComment> SKIP :
//{
// "\n" : DEFAULT
//}



TOKEN :
{
 	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >
|	< #ALPHANUM: (<LETTER> | <DIGIT>) >

}
//TokenManagerdecs
TOKEN :
{
 	< tBEGIN: "begin" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "inicio funcion");
 		}
|	< tBOOL: "boolean" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "inicio funcion");
 		}
|	< tCHAR: "character" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "inicio funcion");
 		}
|	< tINT: "integer" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "inicio funcion");
 		}
//constantes tipos
|	< tVINT: (<DIGIT>)+ >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "constante entera");
 		}
|	< tVCHAR: "'"<LETTER>"'" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "constante char");
 		}
|	< tTRUE: "true" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "constante bool true");
 		}
|	< tFALSE: "false" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "constante bool false");
 		}
|	< tVSTRING: "\""(~["\n","\r"])+"\"" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "constante string");
 		}
//simbolos
|	< tCOMMA: "," >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "simbolo coma");
 		}
|	< tPCOMMA: ";" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "simbolo punto y coma");
 		}
|	< tSBR: "(" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "simbolo parentesis abierto");
 		}
|	< tEBR: ")" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "simbolo parentesis cerrado");
 		}
|	< tISQBR: "[" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "simbolo corchete abierto");
 		}
|	< tESQBR: "]" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "simbolo corchete cerrado");
 		}
//logica
|	< tLESS: "<" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "operador mayor");
 		}
|	< tMORE: ">" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "operador menor");
 		}
|	< tLESSEQ: "<=" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "operador mayor o igual);
 		}
|	< tMOREEQ: ">=" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "operador menor o igual");
 		}
|	< tNOTEQ: "<>" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "operador igual");
 		}
|	< tASSIGN: ":=" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "operador asignacion");
 		}
//aritmetica
|	< tNEG: "-" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "operador menos);
 		}
|	< tPOS: "+" >
 		{
 			//mostrar la información pedida
			informacion(matchedToken, "operador mas");
 		}
//palabras reservadas en minusculas
|	< tPROC: "procedure" >
|	< tFUNCT: "function" >
|	< tRETURN: "return" >
|	< tVAL: "val" >
|	< tREF: "ref" >
|	< tIS: "is" >
|	< tPUT: "put" >
|	< tPUTL: "put_line" >
|	< tEND: "end" >
|	< tIF: "if" >
|	< tELSE: "else" >
|	< tWHILE: "while" >
|	< tDO: "do" >
|	< tTHEN: "then" >
//identificador, no se si existe ?
//|	< tID: ("_"(<ALPHANUM>|<ALPHANUM>"_")* | <LETTER>("_"<ALPHANUM>|<ALPHANUM>)*"_"?) >

//empeiza por barra y no hay dos barras
//_(x|x_)* 
//empieza por letra y no hay dos barras
//y(_x|x)*_?

}

//------------ Símbolo inicial de la gramática. Para análisis léxico no hace falta más
void S () : 
{

}
{
	( 
	< tBEGIN > 		| < tBOOL > 	| < tCHAR > 	| < tINT> 		| < tVINT > 		| < tVCHAR > 		| < tTRUE > 
	| < tFALSE > 	| < tVSTRING >	| < tCOMMA > 	| < tPCOMMA > 	| < tSBR > 			| < tEBR > 			| < tISQBR > 	
	| < tESQBR > 	| < tLESS >		| < tMORE > 	| < tLESSEQ > 	| < tMOREEQ > 		| < tNOTEQ > 		| < tASSIGN > 		
	| < tNEG >		| < tPOS > 		| < tPROC >		| < tFUNCT > 	| < tRETURN > 		| < tVAL > 			| < tREF > 		
	| < tIS >		| < tPUT >		| < tPUTL > 	| < tEND > 		| < tIF >			| < tELSE > 		| < tWHILE > 	
	| < tDO > 		| < tTHEN > 	| < tID >
	)+
	< EOF >
}
